/* 0.24.1 */import { BoxedExpression, Rational } from '../public';
export declare function isRational(x: any | null): x is Rational;
export declare function isMachineRational(x: any | null): x is [number, number];
export declare function isBigRational(x: any | null): x is [bigint, bigint];
export declare function isRationalZero(x: Rational): boolean;
export declare function isRationalOne(x: Rational): boolean;
export declare function isRationalInteger(x: Rational): boolean;
export declare function isRationalNegativeOne(x: Rational): boolean;
export declare function machineNumerator(x: Rational): number;
export declare function machineDenominator(x: Rational): number;
export declare function isNeg(x: Rational): boolean;
export declare function neg(x: [number, number]): [number, number];
export declare function neg(x: [bigint, bigint]): [bigint, bigint];
export declare function neg(x: Rational): Rational;
export declare function inverse(x: [number, number]): [number, number];
export declare function inverse(x: [bigint, bigint]): [bigint, bigint];
export declare function inverse(x: Rational): Rational;
export declare function asRational(expr: BoxedExpression): Rational | undefined;
/**
 * Add a literal numeric value to a rational.
 * If the rational is a bigint, this is a hint to do the calculation in bigint
 * (no need to check `bignumPreferred()`).
 * @param lhs
 * @param rhs
 * @returns
 */
export declare function add(lhs: Rational, rhs: BoxedExpression | Rational): Rational;
export declare function mul(lhs: Rational, rhs: BoxedExpression | Rational): Rational;
export declare function div(lhs: Rational, rhs: Rational): Rational;
export declare function pow(r: Rational, exp: number): Rational;
export declare function sqrt(r: Rational): Rational | undefined;
export declare function reducedRational(r: [number, number]): [number, number];
export declare function reducedRational(r: [bigint, bigint]): [bigint, bigint];
export declare function reducedRational(r: Rational): Rational;
/** Return a rational approximation of x */
export declare function rationalize(x: number): [n: number, d: number] | number;
/** Return [factor, root] such that factor * sqrt(root) = n
 * when factor and root are rationals
 */
export declare function reduceRationalSquareRoot(n: Rational): [factor: Rational, root: Rational];
